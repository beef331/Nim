#
#
#            Nim's Runtime Library
#        (c) Copyright 2015 Nim Contributors
#
#    See the file "copying.txt", included in this
#    distribution, for details about the copyright.
#

from std/math import floor, log10
from std/strformat import fmt

import mersenne

## XXX: Once this is good enough move this into the stdlib, for now mature in
##      the compiler
## 
## :Author: Saem Ghani
##
## This module implements property based testing facilities.
## 
## Heavily inspired by the excellent
## [Fast Check library](https://github.com/dubzzz/fast-check).
## 
## Concepts:
## * predicate - a function which given a value indicates true or false
## * arbitrary - generator of arbitrary value for some set of values
## * property - a condition a value must hold to, given a predicate
## * run - test a single value against a property
## 
## Future directions:
## * properties with predefined examples -- not purely random
## * before and after run hooks for properties
## * support for multiple random number generators
## * optimise arbitraries for Map/Filter/etc via variants, but allow extension
## * distribution control
## * model based checking
## * async testing
## * shrinking

type
  PTStatus* = enum
    ## the result of a single run/predicate check
    ## XXX: likely to be changed to a variant to support, true/false/error+data
    ptFail,
    ptPreCondFail,
    ptPass

  RunId* = range[1..high(int)]
    ## sequential id of the run, starts from 1
  
  RunIdInternal = int
   ## separate from `RunId` to support 0 value, indicating non-specified
  
  Predicate*[T] = proc(s: T): PTStatus
    ## test function to see if a property holds
  
  Random* = object
    ## random number generator, allows abstraction over algorithm
    seed: uint32
    rng: MersenneTwister
  
  Arbitrary*[T] = object of RootObj
    ## arbitrary value generator for some type T
    mgenerate: proc(a: Arbitrary[T], mrng: Random): Shrinkable[T]
  
  Shrinkable*[T] = object
    ## future support for shrinking
    value: T

  Property*[T] = object
    ## condition an arbitrary set of values must hold, given a predicate
    arb: Arbitrary[T]
    predicate: Predicate[T]
  
  Frequency* = int
    ## future use to allow specification of biased generation
  
  # Extra Arbitraries for various circumstances

  MapArbitrary*[T, U] = object of Arbitrary[U]
    ## mapped version of an arbitrary
    mapper: proc(t: T): U
      ## proc used to refine the arbitrary
    mgenerateOrig: proc(a: Arbitrary[T], mrng: Random): Shrinkable[T]
      ## store the original here so we can wrap it with `mapper`

  FilterArbitrary*[T] = object of Arbitrary[T]
    ## filtered version of an arbitrary
    predicate: proc(t: T): bool
      ## proc used to filter the values generated by arbitrary
    mgenerateOrig: proc(a: Arbitrary[T], mrng: Random): Shrinkable[T]
      ## store the original here so we can filter with `predicate` to a subset

#-- Run Id

const noRunId = 0.RunIdInternal

proc isUnspecified(r: RunIdInternal): bool =
  ## used for default param handling
  result = r.uint == 0

proc newRun(): RunId = 1.RunId

proc runComplete(r: var RunId): RunId =
  ## marks the current run as complete and returns the preivous RunId
  result = r
  inc r

proc runIdToFrequency(r: RunId): int =
  2 + toInt(floor(log10(r.int.float)))

#-- Shrinkable

# These seem redundant with Arbitraries, this is mostly for convenience. The
# main reason is that these represent map/filter/etc over a singular shrinkable
# valid value -- which might need particular care. The convenience is when we
# actually implement shrinking and distinguishing specific valid instance vs
# intermediate values an Arbitrary might generate along the way to generating a
# valid value are not the same thing.

proc map[T, U](s: Shrinkable[T], mapper: proc(t: T): U): Shrinkable[U] =
  result = Shrinkable(value: mapper(s.value))

proc filter[T](s: Shrinkable[T], predicate: proc(t: T): bool): Shrinkable[T] =
  result = Shrinkable(value: predicate(s.value))

#-- Arbitrary

proc generate*[T](a: Arbitrary[T], mrng: Random): Shrinkable[T] =
  ## calls the internal implementation
  a.mgenerate(a, mrng)

proc map*[T,U](a: Arbitrary[T], mapper: proc(t: T): U): Arbitrary[U] =
  ## creates a new Arbitrary with mapped values
  ## XXX: constraining U by T isn't possible right now, need to fix generics
  let
    mgenerateOrig = a.mgenerate
    mgenerate = proc(o: Arbirary[T], mrng: Random): Shrinkable[U] =
                  let f = cast[MapArbitrary[T, U]](o)
                  result = f.mgenerateOrig(o, mrng).map(f.mapper)

  return MapArbitrary(
    mgenerate: mgenerate,
    mapper: mapper,
    mgenerateOrig: mgenerateOrig
  )

proc filter*[T](a: Arbitrary[T], predicate: proc(t: T): bool): Arbitrary[T] =
  ## creates a new Arbitrary with filtered values, aggressive filters can lead
  ## to exhausted values.
  let
    mgenerateOrig = a.mgenerate
    mgenerate = proc(o: Arbirary[T], mrng: Random): Shrinkable[U] =
                  let f = cast[FilterArbitrary[T, U]](o)
                  var g = f.mgenerateOrig(o, mrng)
                  while not f.predicate(g.value):
                    g = f.mgenerateOrig(o, mrng)
                  result = cast[Shrinkable[U]](g)

  return FilterArbitrary(
    mgenerate: mgenerate,
    predicate: predicate,
    mgenerateOrig: mgenerateOrig
  )

#-- Property

proc newProperty*[T](arb: Arbitrary[T], p: Predicate): Property[T] =
  result = Property(arb: arb, predicate: p)

proc withBias[T](arb: Arbitrary[T], f: Frequency): Arbitrary[T] =
  ## create an arbitrary with bias
  ## XXX: implement biasing, 
  return arb

proc generateAux[T](p: Property[T], mrng: Random,
                    r: RunIdInternal): Shrinkable[T] =
  result =
    if r.isUnspecified:
      p.arb.withBias(runIdToFrequency(r)).generate(mrng)
    else:
      p.arb.generate(mrng)

proc generate*[T](p: Property[T], mrng: Random, runId: RunId): Shrinkable[T] =
  return generateAux(p, mrng, runId)

proc generate*[T](p: Property[T], mrng: Random): Shrinkable[T] =
  return generateAux(p, mrng, noRunId)

proc run*[T](p: Property[T], v: T): PTStatus =
  try:
    result = p.predicate(v)
  except:
    # XXX: do some exception related checking here, for now pass through
    raise getCurrentException()
  finally:
    # XXX: for hooks
    discard

#-- Random Number Generation

proc newRandom(seed: uint32 = 0): Random =
  Random(seed: seed, rng: newMersenneTwister(seed))

#-- Check Properties

type
  AssertParams* = object
    ## parameters for asserting properties
    ## XXX: add more params to control tests, eg:
    ##      * `examples` as a seq[T], for default values
    seed*: uint32
    random*: Random
    runsBeforeSuccess*: range[1..high(int)]

  AssertRun* = object
    ## state for a runnable or running property assertion
    currentRun: RunIdInternal

  AssertReport* = bool
  # AssertReport* = object
    ## result of a property assertion, with all runs information
    ## XXX: support async and streaming (iterator? CPS? magical other thing?)
    # path: string
    # XXX: complete me

proc defaultAssertParams(): AssertParams =
  let seed: uint32 = 1
  result = AssertParams(seed: seed, random: newRandom(seed),
                        runsBeforeSuccess: 10)

proc assertProperty*[T](p: Property[T], params: AssertParams = defaultAssertParams()): AssertReport =
  var
    runId = newRun()
  
  while(runId <= params.runsBeforeSucces):
    let
      s: Shrinkable[T] = p.generate(params.random, runId)
      r: PTStatus = p.run(s.value)
      didSucceed = r notin {ptFail, ptPreCondFail}
    
    runId.runComplete()

    # XXX: this shouldn't be an doAssert like this, need a proper report
    doAssert didSucceed, fmt"Fail({runId}): {r} - {s.value}"
  
  # XXX: if we made it this far assume it worked
  return true
